var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
// Note that these imports are generated by the `witx-bindgen` CLI tool
import * as i from './witx/imports.js';
import { Exports, Tarball } from './witx/exports.js';
// Read global state from the DOM
const input = document.getElementById('input-url');
const button = document.getElementById('input-button');
const form = document.getElementById('form');
const allFiles = document.getElementById('files');
const editor = ace.edit("editor");
editor.setReadOnly(true);
editor.setOption("useWorker", false);
editor.session.setMode(null);
const modelist = ace.require("ace/ext/modelist");
const successList = document.querySelectorAll('.success');
const errorList = document.querySelectorAll('.error');
const error = document.getElementById('error');
// Setup the import object which is used to instantiate the WebAssembly module.
const importsToWasm = {
    fetch(url) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const response = yield fetch(url);
                const hostResponse = new HostResponse(response);
                return { tag: 'ok', val: hostResponse };
            }
            catch (e) {
                const err = { tag: 'Failure', val: e.toString() };
                return { tag: 'err', val: err };
            }
        });
    },
    log: msg => console.log(msg),
    logErr: msg => console.error(msg),
};
// Instantiates the wasm module and makes the page interactive after the module
// is loaded.
function init() {
    return __awaiter(this, void 0, void 0, function* () {
        const importObject = {};
        let instance;
        i.addImportsToImports(importObject, importsToWasm, name => instance.exports[name]);
        const wasm = new Exports();
        yield wasm.instantiate(fetch('./witx_async_demo.wasm'), importObject);
        instance = wasm.instance;
        input.disabled = false;
        button.disabled = false;
        form.onsubmit = function (e) {
            return __awaiter(this, void 0, void 0, function* () {
                e.preventDefault();
                button.disabled = true;
                input.disabled = true;
                try {
                    const tarball = yield Tarball.fetch(wasm, input.value);
                    if (tarball.tag == 'ok') {
                        render(tarball.val);
                    }
                    else {
                        renderError(tarball.val);
                    }
                }
                finally {
                    button.disabled = false;
                    input.disabled = false;
                }
            });
        };
    });
}
function render(tarball) {
    for (let element of successList)
        element.style.display = 'block';
    for (let element of errorList)
        element.style.display = 'none';
    const ul = document.createElement('ul');
    let i = 0;
    for (let file of tarball.files()) {
        const a = document.createElement('a');
        a.href = '#';
        let j = i;
        a.onclick = function () {
            editor.setValue(tarball.contents(j));
            editor.clearSelection();
            editor.resize();
            const selected = ul.querySelector('.selected');
            if (selected)
                selected.classList.remove('selected');
            a.classList.add("selected");
            const mode = modelist.getModeForPath(file).mode;
            editor.session.setMode(mode);
            return false;
        };
        const code = document.createElement('code');
        code.innerText = file;
        a.appendChild(code);
        const li = document.createElement('li');
        li.appendChild(a);
        ul.appendChild(li);
        i += 1;
    }
    while (allFiles.firstChild)
        allFiles.removeChild(allFiles.firstChild);
    allFiles.appendChild(ul);
    ul.querySelector('a').click();
}
function renderError(err) {
    for (let element of errorList)
        element.style.display = 'block';
    for (let element of successList)
        element.style.display = 'none';
    error.innerText = err.val;
}
// Adapter from the browser's `Response` class to the type of `Response`
// expected by the wasm module.
class HostResponse {
    constructor(response) {
        this.response = response;
    }
    headers() {
        return new HostHeaders(this.response.headers);
    }
    body() {
        return __awaiter(this, void 0, void 0, function* () {
            const arrayBuffer = yield this.response.arrayBuffer();
            return new Uint8Array(arrayBuffer);
        });
    }
    status() {
        return this.response.status;
    }
    statusText() {
        return this.response.statusText;
    }
}
// Adapter from the browser's `Headers` class to the type of `Headers`
// expected by the wasm module.
class HostHeaders {
    constructor(headers) {
        this.headers = headers;
    }
    get(name) {
        const ret = this.headers.get(name);
        if (ret === null)
            return [];
        return ret.split(',');
    }
    entries() {
        const ret = [];
        for (let [name, value] of this.headers.entries())
            ret.push([name, value.split(',')]);
        return ret;
    }
}
init();
